{"ast":null,"code":"/*global window:false, self:false, define:false, module:false */\n\n/**\n * @license IDBWrapper - A cross-browser wrapper for IndexedDB\n * Version 1.7.2\n * Copyright (c) 2011 - 2017 Jens Arps\n * http://jensarps.de/\n *\n * Licensed under the MIT license\n */\n(function (name, definition, global) {\n  'use strict';\n\n  if (typeof define === 'function') {\n    define(definition);\n  } else if (typeof module !== 'undefined' && module.exports) {\n    module.exports = definition();\n  } else {\n    global[name] = definition();\n  }\n})('IDBStore', function () {\n  'use strict';\n\n  var defaultErrorHandler = function (error) {\n    throw error;\n  };\n\n  var defaultSuccessHandler = function () {};\n\n  var defaults = {\n    storeName: 'Store',\n    storePrefix: 'IDBWrapper-',\n    dbVersion: 1,\n    keyPath: 'id',\n    autoIncrement: true,\n    onStoreReady: function () {},\n    onError: defaultErrorHandler,\n    indexes: [],\n    implementationPreference: ['indexedDB', 'webkitIndexedDB', 'mozIndexedDB', 'shimIndexedDB']\n  };\n  /**\n   *\n   * The IDBStore constructor\n   *\n   * @constructor\n   * @name IDBStore\n   * @version 1.7.2\n   *\n   * @param {Object} [kwArgs] An options object used to configure the store and\n   *  set callbacks\n   * @param {String} [kwArgs.storeName='Store'] The name of the store\n   * @param {String} [kwArgs.storePrefix='IDBWrapper-'] A prefix that is\n   *  internally used to construct the name of the database, which will be\n   *  kwArgs.storePrefix + kwArgs.storeName\n   * @param {Number} [kwArgs.dbVersion=1] The version of the store\n   * @param {String} [kwArgs.keyPath='id'] The key path to use. If you want to\n   *  setup IDBWrapper to work with out-of-line keys, you need to set this to\n   *  `null`\n   * @param {Boolean} [kwArgs.autoIncrement=true] If set to true, IDBStore will\n   *  automatically make sure a unique keyPath value is present on each object\n   *  that is stored.\n   * @param {Function} [kwArgs.onStoreReady] A callback to be called when the\n   *  store is ready to be used.\n   * @param {Function} [kwArgs.onError=throw] A callback to be called when an\n   *  error occurred during instantiation of the store.\n   * @param {Array} [kwArgs.indexes=[]] An array of indexData objects\n   *  defining the indexes to use with the store. For every index to be used\n   *  one indexData object needs to be passed in the array.\n   *  An indexData object is defined as follows:\n   * @param {Object} [kwArgs.indexes.indexData] An object defining the index to\n   *  use\n   * @param {String} kwArgs.indexes.indexData.name The name of the index\n   * @param {String} [kwArgs.indexes.indexData.keyPath] The key path of the index\n   * @param {Boolean} [kwArgs.indexes.indexData.unique] Whether the index is unique\n   * @param {Boolean} [kwArgs.indexes.indexData.multiEntry] Whether the index is multi entry\n   * @param {Array} [kwArgs.implementationPreference=['indexedDB','webkitIndexedDB','mozIndexedDB','shimIndexedDB']] An array of strings naming implementations to be used, in order or preference\n   * @param {Function} [onStoreReady] A callback to be called when the store\n   * is ready to be used.\n   * @example\n   // create a store for customers with an additional index over the\n   // `lastname` property.\n   var myCustomerStore = new IDBStore({\n       dbVersion: 1,\n       storeName: 'customer-index',\n       keyPath: 'customerid',\n       autoIncrement: true,\n       onStoreReady: populateTable,\n       indexes: [\n           { name: 'lastname', keyPath: 'lastname', unique: false, multiEntry: false }\n       ]\n   });\n   * @example\n   // create a generic store\n   var myCustomerStore = new IDBStore({\n       storeName: 'my-data-store',\n       onStoreReady: function(){\n           // start working with the store.\n       }\n   });\n   */\n\n  var IDBStore = function (kwArgs, onStoreReady) {\n    if (typeof onStoreReady == 'undefined' && typeof kwArgs == 'function') {\n      onStoreReady = kwArgs;\n    }\n\n    if (Object.prototype.toString.call(kwArgs) != '[object Object]') {\n      kwArgs = {};\n    }\n\n    for (var key in defaults) {\n      this[key] = typeof kwArgs[key] != 'undefined' ? kwArgs[key] : defaults[key];\n    }\n\n    this.dbName = this.storePrefix + this.storeName;\n    this.dbVersion = parseInt(this.dbVersion, 10) || 1;\n    onStoreReady && (this.onStoreReady = onStoreReady);\n    var env = typeof window == 'object' ? window : self;\n    var availableImplementations = this.implementationPreference.filter(function (implName) {\n      return implName in env;\n    });\n    this.implementation = availableImplementations[0];\n    this.idb = env[this.implementation];\n    this.keyRange = env.IDBKeyRange || env.webkitIDBKeyRange || env.mozIDBKeyRange;\n    this.consts = {\n      'READ_ONLY': 'readonly',\n      'READ_WRITE': 'readwrite',\n      'VERSION_CHANGE': 'versionchange',\n      'NEXT': 'next',\n      'NEXT_NO_DUPLICATE': 'nextunique',\n      'PREV': 'prev',\n      'PREV_NO_DUPLICATE': 'prevunique'\n    };\n    this.openDB();\n  };\n  /** @lends IDBStore.prototype */\n\n\n  var proto = {\n    /**\n     * A pointer to the IDBStore ctor\n     *\n     * @private\n     * @type {Function}\n     * @constructs\n     */\n    constructor: IDBStore,\n\n    /**\n     * The version of IDBStore\n     *\n     * @type {String}\n     */\n    version: '1.7.2',\n\n    /**\n     * A reference to the IndexedDB object\n     *\n     * @type {IDBDatabase}\n     */\n    db: null,\n\n    /**\n     * The full name of the IndexedDB used by IDBStore, composed of\n     * this.storePrefix + this.storeName\n     *\n     * @type {String}\n     */\n    dbName: null,\n\n    /**\n     * The version of the IndexedDB used by IDBStore\n     *\n     * @type {Number}\n     */\n    dbVersion: null,\n\n    /**\n     * A reference to the objectStore used by IDBStore\n     *\n     * @type {IDBObjectStore}\n     */\n    store: null,\n\n    /**\n     * The store name\n     *\n     * @type {String}\n     */\n    storeName: null,\n\n    /**\n     * The prefix to prepend to the store name\n     *\n     * @type {String}\n     */\n    storePrefix: null,\n\n    /**\n     * The key path\n     *\n     * @type {String}\n     */\n    keyPath: null,\n\n    /**\n     * Whether IDBStore uses autoIncrement\n     *\n     * @type {Boolean}\n     */\n    autoIncrement: null,\n\n    /**\n     * The indexes used by IDBStore\n     *\n     * @type {Array}\n     */\n    indexes: null,\n\n    /**\n     * The implemantations to try to use, in order of preference\n     *\n     * @type {Array}\n     */\n    implementationPreference: null,\n\n    /**\n     * The actual implementation being used\n     *\n     * @type {String}\n     */\n    implementation: '',\n\n    /**\n     * The callback to be called when the store is ready to be used\n     *\n     * @type {Function}\n     */\n    onStoreReady: null,\n\n    /**\n     * The callback to be called if an error occurred during instantiation\n     * of the store\n     *\n     * @type {Function}\n     */\n    onError: null,\n\n    /**\n     * The internal insertID counter\n     *\n     * @type {Number}\n     * @private\n     */\n    _insertIdCount: 0,\n\n    /**\n     * Opens an IndexedDB; called by the constructor.\n     *\n     * Will check if versions match and compare provided index configuration\n     * with existing ones, and update indexes if necessary.\n     *\n     * Will call this.onStoreReady() if everything went well and the store\n     * is ready to use, and this.onError() is something went wrong.\n     *\n     * @private\n     *\n     */\n    openDB: function () {\n      var openRequest = this.idb.open(this.dbName, this.dbVersion);\n      var preventSuccessCallback = false;\n\n      openRequest.onerror = function (errorEvent) {\n        if (hasVersionError(errorEvent)) {\n          this.onError(new Error('The version number provided is lower than the existing one.'));\n        } else {\n          var error;\n\n          if (errorEvent.target.error) {\n            error = errorEvent.target.error;\n          } else {\n            var errorMessage = 'IndexedDB unknown error occurred when opening DB ' + this.dbName + ' version ' + this.dbVersion;\n\n            if ('errorCode' in errorEvent.target) {\n              errorMessage += ' with error code ' + errorEvent.target.errorCode;\n            }\n\n            error = new Error(errorMessage);\n          }\n\n          this.onError(error);\n        }\n      }.bind(this);\n\n      openRequest.onsuccess = function (event) {\n        if (preventSuccessCallback) {\n          return;\n        }\n\n        if (this.db) {\n          this.onStoreReady();\n          return;\n        }\n\n        this.db = event.target.result;\n\n        if (typeof this.db.version == 'string') {\n          this.onError(new Error('The IndexedDB implementation in this browser is outdated. Please upgrade your browser.'));\n          return;\n        }\n\n        if (!this.db.objectStoreNames.contains(this.storeName)) {\n          // We should never ever get here.\n          // Lets notify the user anyway.\n          this.onError(new Error('Object store couldn\\'t be created.'));\n          return;\n        }\n\n        var emptyTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n        this.store = emptyTransaction.objectStore(this.storeName); // check indexes\n\n        var existingIndexes = Array.prototype.slice.call(this.getIndexList());\n        this.indexes.forEach(function (indexData) {\n          var indexName = indexData.name;\n\n          if (!indexName) {\n            preventSuccessCallback = true;\n            this.onError(new Error('Cannot create index: No index name given.'));\n            return;\n          }\n\n          this.normalizeIndexData(indexData);\n\n          if (this.hasIndex(indexName)) {\n            // check if it complies\n            var actualIndex = this.store.index(indexName);\n            var complies = this.indexComplies(actualIndex, indexData);\n\n            if (!complies) {\n              preventSuccessCallback = true;\n              this.onError(new Error('Cannot modify index \"' + indexName + '\" for current version. Please bump version number to ' + (this.dbVersion + 1) + '.'));\n            }\n\n            existingIndexes.splice(existingIndexes.indexOf(indexName), 1);\n          } else {\n            preventSuccessCallback = true;\n            this.onError(new Error('Cannot create new index \"' + indexName + '\" for current version. Please bump version number to ' + (this.dbVersion + 1) + '.'));\n          }\n        }, this);\n\n        if (existingIndexes.length) {\n          preventSuccessCallback = true;\n          this.onError(new Error('Cannot delete index(es) \"' + existingIndexes.toString() + '\" for current version. Please bump version number to ' + (this.dbVersion + 1) + '.'));\n        }\n\n        preventSuccessCallback || this.onStoreReady();\n      }.bind(this);\n\n      openRequest.onupgradeneeded = function (\n      /* IDBVersionChangeEvent */\n      event) {\n        this.db = event.target.result;\n\n        if (this.db.objectStoreNames.contains(this.storeName)) {\n          this.store = event.target.transaction.objectStore(this.storeName);\n        } else {\n          var optionalParameters = {\n            autoIncrement: this.autoIncrement\n          };\n\n          if (this.keyPath !== null) {\n            optionalParameters.keyPath = this.keyPath;\n          }\n\n          this.store = this.db.createObjectStore(this.storeName, optionalParameters);\n        }\n\n        var existingIndexes = Array.prototype.slice.call(this.getIndexList());\n        this.indexes.forEach(function (indexData) {\n          var indexName = indexData.name;\n\n          if (!indexName) {\n            preventSuccessCallback = true;\n            this.onError(new Error('Cannot create index: No index name given.'));\n          }\n\n          this.normalizeIndexData(indexData);\n\n          if (this.hasIndex(indexName)) {\n            // check if it complies\n            var actualIndex = this.store.index(indexName);\n            var complies = this.indexComplies(actualIndex, indexData);\n\n            if (!complies) {\n              // index differs, need to delete and re-create\n              this.store.deleteIndex(indexName);\n              this.store.createIndex(indexName, indexData.keyPath, {\n                unique: indexData.unique,\n                multiEntry: indexData.multiEntry\n              });\n            }\n\n            existingIndexes.splice(existingIndexes.indexOf(indexName), 1);\n          } else {\n            this.store.createIndex(indexName, indexData.keyPath, {\n              unique: indexData.unique,\n              multiEntry: indexData.multiEntry\n            });\n          }\n        }, this);\n\n        if (existingIndexes.length) {\n          existingIndexes.forEach(function (_indexName) {\n            this.store.deleteIndex(_indexName);\n          }, this);\n        }\n      }.bind(this);\n    },\n\n    /**\n     * Deletes the database used for this store if the IDB implementations\n     * provides that functionality.\n     *\n     * @param {Function} [onSuccess] A callback that is called if deletion\n     *  was successful.\n     * @param {Function} [onError] A callback that is called if deletion\n     *  failed.\n     */\n    deleteDatabase: function (onSuccess, onError) {\n      if (this.idb.deleteDatabase) {\n        this.db.close();\n        var deleteRequest = this.idb.deleteDatabase(this.dbName);\n        deleteRequest.onsuccess = onSuccess;\n        deleteRequest.onerror = onError;\n      } else {\n        onError(new Error('Browser does not support IndexedDB deleteDatabase!'));\n      }\n    },\n\n    /*********************\n     * data manipulation *\n     *********************/\n\n    /**\n     * Puts an object into the store. If an entry with the given id exists,\n     * it will be overwritten. This method has a different signature for inline\n     * keys and out-of-line keys; please see the examples below.\n     *\n     * @param {*} [key] The key to store. This is only needed if IDBWrapper\n     *  is set to use out-of-line keys. For inline keys - the default scenario -\n     *  this can be omitted.\n     * @param {Object} value The data object to store.\n     * @param {Function} [onSuccess] A callback that is called if insertion\n     *  was successful.\n     * @param {Function} [onError] A callback that is called if insertion\n     *  failed.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     * @example\n     // Storing an object, using inline keys (the default scenario):\n     var myCustomer = {\n         customerid: 2346223,\n         lastname: 'Doe',\n         firstname: 'John'\n     };\n     myCustomerStore.put(myCustomer, mySuccessHandler, myErrorHandler);\n     // Note that passing success- and error-handlers is optional.\n     * @example\n     // Storing an object, using out-of-line keys:\n     var myCustomer = {\n         lastname: 'Doe',\n         firstname: 'John'\n     };\n     myCustomerStore.put(2346223, myCustomer, mySuccessHandler, myErrorHandler);\n     // Note that passing success- and error-handlers is optional.\n     */\n    put: function (key, value, onSuccess, onError) {\n      if (this.keyPath !== null) {\n        onError = onSuccess;\n        onSuccess = value;\n        value = key;\n      }\n\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n      var hasSuccess = false,\n          result = null,\n          putRequest;\n      var putTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n\n      putTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n\n      putTransaction.onabort = onError;\n      putTransaction.onerror = onError;\n\n      if (this.keyPath !== null) {\n        // in-line keys\n        this._addIdPropertyIfNeeded(value);\n\n        putRequest = putTransaction.objectStore(this.storeName).put(value);\n      } else {\n        // out-of-line keys\n        putRequest = putTransaction.objectStore(this.storeName).put(value, key);\n      }\n\n      putRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n\n      putRequest.onerror = onError;\n      return putTransaction;\n    },\n\n    /**\n     * Retrieves an object from the store. If no entry exists with the given id,\n     * the success handler will be called with null as first and only argument.\n     *\n     * @param {*} key The id of the object to fetch.\n     * @param {Function} [onSuccess] A callback that is called if fetching\n     *  was successful. Will receive the object as only argument.\n     * @param {Function} [onError] A callback that will be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    get: function (key, onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n      var hasSuccess = false,\n          result = null;\n      var getTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n\n      getTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n\n      getTransaction.onabort = onError;\n      getTransaction.onerror = onError;\n      var getRequest = getTransaction.objectStore(this.storeName).get(key);\n\n      getRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n\n      getRequest.onerror = onError;\n      return getTransaction;\n    },\n\n    /**\n     * Removes an object from the store.\n     *\n     * @param {*} key The id of the object to remove.\n     * @param {Function} [onSuccess] A callback that is called if the removal\n     *  was successful.\n     * @param {Function} [onError] A callback that will be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    remove: function (key, onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n      var hasSuccess = false,\n          result = null;\n      var removeTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n\n      removeTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n\n      removeTransaction.onabort = onError;\n      removeTransaction.onerror = onError;\n      var deleteRequest = removeTransaction.objectStore(this.storeName)['delete'](key);\n\n      deleteRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n\n      deleteRequest.onerror = onError;\n      return removeTransaction;\n    },\n\n    /**\n     * Runs a batch of put and/or remove operations on the store.\n     *\n     * @param {Array} dataArray An array of objects containing the operation to run\n     *  and the data object (for put operations).\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    batch: function (dataArray, onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n\n      if (Object.prototype.toString.call(dataArray) != '[object Array]') {\n        onError(new Error('dataArray argument must be of type Array.'));\n      } else if (dataArray.length === 0) {\n        return onSuccess(true);\n      }\n\n      var count = dataArray.length;\n      var called = false;\n      var hasSuccess = false;\n      var batchTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n\n      batchTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(hasSuccess);\n      };\n\n      batchTransaction.onabort = onError;\n      batchTransaction.onerror = onError;\n\n      var onItemSuccess = function () {\n        count--;\n\n        if (count === 0 && !called) {\n          called = true;\n          hasSuccess = true;\n        }\n      };\n\n      dataArray.forEach(function (operation) {\n        var type = operation.type;\n        var key = operation.key;\n        var value = operation.value;\n\n        var onItemError = function (err) {\n          batchTransaction.abort();\n\n          if (!called) {\n            called = true;\n            onError(err, type, key);\n          }\n        };\n\n        if (type == 'remove') {\n          var deleteRequest = batchTransaction.objectStore(this.storeName)['delete'](key);\n          deleteRequest.onsuccess = onItemSuccess;\n          deleteRequest.onerror = onItemError;\n        } else if (type == 'put') {\n          var putRequest;\n\n          if (this.keyPath !== null) {\n            // in-line keys\n            this._addIdPropertyIfNeeded(value);\n\n            putRequest = batchTransaction.objectStore(this.storeName).put(value);\n          } else {\n            // out-of-line keys\n            putRequest = batchTransaction.objectStore(this.storeName).put(value, key);\n          }\n\n          putRequest.onsuccess = onItemSuccess;\n          putRequest.onerror = onItemError;\n        }\n      }, this);\n      return batchTransaction;\n    },\n\n    /**\n     * Takes an array of objects and stores them in a single transaction.\n     *\n     * @param {Array} dataArray An array of objects to store\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    putBatch: function (dataArray, onSuccess, onError) {\n      var batchData = dataArray.map(function (item) {\n        return {\n          type: 'put',\n          value: item\n        };\n      });\n      return this.batch(batchData, onSuccess, onError);\n    },\n\n    /**\n     * Like putBatch, takes an array of objects and stores them in a single\n     * transaction, but allows processing of the result values.  Returns the\n     * processed records containing the key for newly created records to the\n     * onSuccess calllback instead of only returning true or false for success.\n     * In addition, added the option for the caller to specify a key field that\n     * should be set to the newly created key.\n     *\n     * @param {Array} dataArray An array of objects to store\n     * @param {Object} [options] An object containing optional options\n     * @param {String} [options.keyField=this.keyPath] Specifies a field in the record to update\n     *  with the auto-incrementing key. Defaults to the store's keyPath.\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     *\n     */\n    upsertBatch: function (dataArray, options, onSuccess, onError) {\n      // handle `dataArray, onSuccess, onError` signature\n      if (typeof options == 'function') {\n        onSuccess = options;\n        onError = onSuccess;\n        options = {};\n      }\n\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n      options || (options = {});\n\n      if (Object.prototype.toString.call(dataArray) != '[object Array]') {\n        onError(new Error('dataArray argument must be of type Array.'));\n      }\n\n      var keyField = options.keyField || this.keyPath;\n      var count = dataArray.length;\n      var called = false;\n      var hasSuccess = false;\n      var index = 0; // assume success callbacks are executed in order\n\n      var batchTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n\n      batchTransaction.oncomplete = function () {\n        if (hasSuccess) {\n          onSuccess(dataArray);\n        } else {\n          onError(false);\n        }\n      };\n\n      batchTransaction.onabort = onError;\n      batchTransaction.onerror = onError;\n\n      var onItemSuccess = function (event) {\n        var record = dataArray[index++];\n        record[keyField] = event.target.result;\n        count--;\n\n        if (count === 0 && !called) {\n          called = true;\n          hasSuccess = true;\n        }\n      };\n\n      dataArray.forEach(function (record) {\n        var key = record.key;\n\n        var onItemError = function (err) {\n          batchTransaction.abort();\n\n          if (!called) {\n            called = true;\n            onError(err);\n          }\n        };\n\n        var putRequest;\n\n        if (this.keyPath !== null) {\n          // in-line keys\n          this._addIdPropertyIfNeeded(record);\n\n          putRequest = batchTransaction.objectStore(this.storeName).put(record);\n        } else {\n          // out-of-line keys\n          putRequest = batchTransaction.objectStore(this.storeName).put(record, key);\n        }\n\n        putRequest.onsuccess = onItemSuccess;\n        putRequest.onerror = onItemError;\n      }, this);\n      return batchTransaction;\n    },\n\n    /**\n     * Takes an array of keys and removes matching objects in a single\n     * transaction.\n     *\n     * @param {Array} keyArray An array of keys to remove\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    removeBatch: function (keyArray, onSuccess, onError) {\n      var batchData = keyArray.map(function (key) {\n        return {\n          type: 'remove',\n          key: key\n        };\n      });\n      return this.batch(batchData, onSuccess, onError);\n    },\n\n    /**\n     * Takes an array of keys and fetches matching objects\n     *\n     * @param {Array} keyArray An array of keys identifying the objects to fetch\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @param {String} [arrayType='sparse'] The type of array to pass to the\n     *  success handler. May be one of 'sparse', 'dense' or 'skip'. Defaults to\n     *  'sparse'. This parameter specifies how to handle the situation if a get\n     *  operation did not throw an error, but there was no matching object in\n     *  the database. In most cases, 'sparse' provides the most desired\n     *  behavior. See the examples for details.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     * @example\n     // given that there are two objects in the database with the keypath\n     // values 1 and 2, and the call looks like this:\n     myStore.getBatch([1, 5, 2], onError, function (data) { … }, arrayType);\n      // this is what the `data` array will be like:\n      // arrayType == 'sparse':\n     // data is a sparse array containing two entries and having a length of 3:\n     [Object, 2: Object]\n     0: Object\n     2: Object\n     length: 3\n     // calling forEach on data will result in the callback being called two\n     // times, with the index parameter matching the index of the key in the\n     // keyArray.\n      // arrayType == 'dense':\n     // data is a dense array containing three entries and having a length of 3,\n     // where data[1] is of type undefined:\n     [Object, undefined, Object]\n     0: Object\n     1: undefined\n     2: Object\n     length: 3\n     // calling forEach on data will result in the callback being called three\n     // times, with the index parameter matching the index of the key in the\n     // keyArray, but the second call will have undefined as first argument.\n      // arrayType == 'skip':\n     // data is a dense array containing two entries and having a length of 2:\n     [Object, Object]\n     0: Object\n     1: Object\n     length: 2\n     // calling forEach on data will result in the callback being called two\n     // times, with the index parameter not matching the index of the key in the\n     // keyArray.\n     */\n    getBatch: function (keyArray, onSuccess, onError, arrayType) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n      arrayType || (arrayType = 'sparse');\n\n      if (Object.prototype.toString.call(keyArray) != '[object Array]') {\n        onError(new Error('keyArray argument must be of type Array.'));\n      } else if (keyArray.length === 0) {\n        return onSuccess([]);\n      }\n\n      var data = [];\n      var count = keyArray.length;\n      var called = false;\n      var hasSuccess = false;\n      var result = null;\n      var batchTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n\n      batchTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n\n      batchTransaction.onabort = onError;\n      batchTransaction.onerror = onError;\n\n      var onItemSuccess = function (event) {\n        if (event.target.result || arrayType == 'dense') {\n          data.push(event.target.result);\n        } else if (arrayType == 'sparse') {\n          data.length++;\n        }\n\n        count--;\n\n        if (count === 0) {\n          called = true;\n          hasSuccess = true;\n          result = data;\n        }\n      };\n\n      keyArray.forEach(function (key) {\n        var onItemError = function (err) {\n          called = true;\n          result = err;\n          onError(err);\n          batchTransaction.abort();\n        };\n\n        var getRequest = batchTransaction.objectStore(this.storeName).get(key);\n        getRequest.onsuccess = onItemSuccess;\n        getRequest.onerror = onItemError;\n      }, this);\n      return batchTransaction;\n    },\n\n    /**\n     * Fetches all entries in the store.\n     *\n     * @param {Function} [onSuccess] A callback that is called if the operation\n     *  was successful. Will receive an array of objects.\n     * @param {Function} [onError] A callback that will be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    getAll: function (onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n      var getAllTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n      var store = getAllTransaction.objectStore(this.storeName);\n\n      if (store.getAll) {\n        this._getAllNative(getAllTransaction, store, onSuccess, onError);\n      } else {\n        this._getAllCursor(getAllTransaction, store, onSuccess, onError);\n      }\n\n      return getAllTransaction;\n    },\n\n    /**\n     * Implements getAll for IDB implementations that have a non-standard\n     * getAll() method.\n     *\n     * @param {IDBTransaction} getAllTransaction An open READ transaction.\n     * @param {IDBObjectStore} store A reference to the store.\n     * @param {Function} onSuccess A callback that will be called if the\n     *  operation was successful.\n     * @param {Function} onError A callback that will be called if an\n     *  error occurred during the operation.\n     * @private\n     */\n    _getAllNative: function (getAllTransaction, store, onSuccess, onError) {\n      var hasSuccess = false,\n          result = null;\n\n      getAllTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n\n      getAllTransaction.onabort = onError;\n      getAllTransaction.onerror = onError;\n      var getAllRequest = store.getAll();\n\n      getAllRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n\n      getAllRequest.onerror = onError;\n    },\n\n    /**\n     * Implements getAll for IDB implementations that do not have a getAll()\n     * method.\n     *\n     * @param {IDBTransaction} getAllTransaction An open READ transaction.\n     * @param {IDBObjectStore} store A reference to the store.\n     * @param {Function} onSuccess A callback that will be called if the\n     *  operation was successful.\n     * @param {Function} onError A callback that will be called if an\n     *  error occurred during the operation.\n     * @private\n     */\n    _getAllCursor: function (getAllTransaction, store, onSuccess, onError) {\n      var all = [],\n          hasSuccess = false,\n          result = null;\n\n      getAllTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n\n      getAllTransaction.onabort = onError;\n      getAllTransaction.onerror = onError;\n      var cursorRequest = store.openCursor();\n\n      cursorRequest.onsuccess = function (event) {\n        var cursor = event.target.result;\n\n        if (cursor) {\n          all.push(cursor.value);\n          cursor['continue']();\n        } else {\n          hasSuccess = true;\n          result = all;\n        }\n      };\n\n      cursorRequest.onError = onError;\n    },\n\n    /**\n     * Clears the store, i.e. deletes all entries in the store.\n     *\n     * @param {Function} [onSuccess] A callback that will be called if the\n     *  operation was successful.\n     * @param {Function} [onError] A callback that will be called if an\n     *  error occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    clear: function (onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n      var hasSuccess = false,\n          result = null;\n      var clearTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n\n      clearTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n\n      clearTransaction.onabort = onError;\n      clearTransaction.onerror = onError;\n      var clearRequest = clearTransaction.objectStore(this.storeName).clear();\n\n      clearRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n\n      clearRequest.onerror = onError;\n      return clearTransaction;\n    },\n\n    /**\n     * Checks if an id property needs to present on a object and adds one if\n     * necessary.\n     *\n     * @param {Object} dataObj The data object that is about to be stored\n     * @private\n     */\n    _addIdPropertyIfNeeded: function (dataObj) {\n      if (typeof dataObj[this.keyPath] == 'undefined') {\n        dataObj[this.keyPath] = this._insertIdCount++ + Date.now();\n      }\n    },\n\n    /************\n     * indexing *\n     ************/\n\n    /**\n     * Returns a DOMStringList of index names of the store.\n     *\n     * @return {DOMStringList} The list of index names\n     */\n    getIndexList: function () {\n      return this.store.indexNames;\n    },\n\n    /**\n     * Checks if an index with the given name exists in the store.\n     *\n     * @param {String} indexName The name of the index to look for\n     * @return {Boolean} Whether the store contains an index with the given name\n     */\n    hasIndex: function (indexName) {\n      return this.store.indexNames.contains(indexName);\n    },\n\n    /**\n     * Normalizes an object containing index data and assures that all\n     * properties are set.\n     *\n     * @param {Object} indexData The index data object to normalize\n     * @param {String} indexData.name The name of the index\n     * @param {String} [indexData.keyPath] The key path of the index\n     * @param {Boolean} [indexData.unique] Whether the index is unique\n     * @param {Boolean} [indexData.multiEntry] Whether the index is multi entry\n     */\n    normalizeIndexData: function (indexData) {\n      indexData.keyPath = indexData.keyPath || indexData.name;\n      indexData.unique = !!indexData.unique;\n      indexData.multiEntry = !!indexData.multiEntry;\n    },\n\n    /**\n     * Checks if an actual index complies with an expected index.\n     *\n     * @param {IDBIndex} actual The actual index found in the store\n     * @param {Object} expected An Object describing an expected index\n     * @return {Boolean} Whether both index definitions are identical\n     */\n    indexComplies: function (actual, expected) {\n      var complies = ['keyPath', 'unique', 'multiEntry'].every(function (key) {\n        // IE10 returns undefined for no multiEntry\n        if (key == 'multiEntry' && actual[key] === undefined && expected[key] === false) {\n          return true;\n        } // Compound keys\n\n\n        if (key == 'keyPath' && Object.prototype.toString.call(expected[key]) == '[object Array]') {\n          var exp = expected.keyPath;\n          var act = actual.keyPath; // IE10 can't handle keyPath sequences and stores them as a string.\n          // The index will be unusable there, but let's still return true if\n          // the keyPath sequence matches.\n\n          if (typeof act == 'string') {\n            return exp.toString() == act;\n          } // Chrome/Opera stores keyPath squences as DOMStringList, Firefox\n          // as Array\n\n\n          if (!(typeof act.contains == 'function' || typeof act.indexOf == 'function')) {\n            return false;\n          }\n\n          if (act.length !== exp.length) {\n            return false;\n          }\n\n          for (var i = 0, m = exp.length; i < m; i++) {\n            if (!(act.contains && act.contains(exp[i]) || act.indexOf(exp[i] !== -1))) {\n              return false;\n            }\n          }\n\n          return true;\n        }\n\n        return expected[key] == actual[key];\n      });\n      return complies;\n    },\n\n    /**********\n     * cursor *\n     **********/\n\n    /**\n     * Iterates over the store using the given options and calling onItem\n     * for each entry matching the options.\n     *\n     * @param {Function} onItem A callback to be called for each match\n     * @param {Object} [options] An object defining specific options\n     * @param {String} [options.index=null] A name of an IDBIndex to operate on\n     * @param {String} [options.order=ASC] The order in which to provide the\n     *  results, can be 'DESC' or 'ASC'\n     * @param {Boolean} [options.autoContinue=true] Whether to automatically\n     *  iterate the cursor to the next result\n     * @param {Boolean} [options.filterDuplicates=false] Whether to exclude\n     *  duplicate matches\n     * @param {IDBKeyRange} [options.keyRange=null] An IDBKeyRange to use\n     * @param {Boolean} [options.writeAccess=false] Whether grant write access\n     *  to the store in the onItem callback\n     * @param {Function} [options.onEnd=null] A callback to be called after\n     *  iteration has ended\n     * @param {Function} [options.onError=throw] A callback to be called\n     *  if an error occurred during the operation.\n     * @param {Number} [options.limit=Infinity] Limit the number of returned\n     *  results to this number\n     * @param {Number} [options.offset=0] Skip the provided number of results\n     *  in the resultset\n     * @param {Boolean} [options.allowItemRejection=false] Allows the onItem\n     * function to return a Boolean to accept or reject the current item\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    iterate: function (onItem, options) {\n      options = mixin({\n        index: null,\n        order: 'ASC',\n        autoContinue: true,\n        filterDuplicates: false,\n        keyRange: null,\n        writeAccess: false,\n        onEnd: null,\n        onError: defaultErrorHandler,\n        limit: Infinity,\n        offset: 0,\n        allowItemRejection: false\n      }, options || {});\n      var directionType = options.order.toLowerCase() == 'desc' ? 'PREV' : 'NEXT';\n\n      if (options.filterDuplicates) {\n        directionType += '_NO_DUPLICATE';\n      }\n\n      var hasSuccess = false;\n      var cursorTransaction = this.db.transaction([this.storeName], this.consts[options.writeAccess ? 'READ_WRITE' : 'READ_ONLY']);\n      var cursorTarget = cursorTransaction.objectStore(this.storeName);\n\n      if (options.index) {\n        cursorTarget = cursorTarget.index(options.index);\n      }\n\n      var recordCount = 0;\n\n      cursorTransaction.oncomplete = function () {\n        if (!hasSuccess) {\n          options.onError(null);\n          return;\n        }\n\n        if (options.onEnd) {\n          options.onEnd();\n        } else {\n          onItem(null);\n        }\n      };\n\n      cursorTransaction.onabort = options.onError;\n      cursorTransaction.onerror = options.onError;\n      var cursorRequest = cursorTarget.openCursor(options.keyRange, this.consts[directionType]);\n      cursorRequest.onerror = options.onError;\n\n      cursorRequest.onsuccess = function (event) {\n        var cursor = event.target.result;\n\n        if (cursor) {\n          if (options.offset) {\n            cursor.advance(options.offset);\n            options.offset = 0;\n          } else {\n            var onItemReturn = onItem(cursor.value, cursor, cursorTransaction);\n\n            if (!options.allowItemRejection || onItemReturn !== false) {\n              recordCount++;\n            }\n\n            if (options.autoContinue) {\n              if (recordCount + options.offset < options.limit) {\n                cursor['continue']();\n              } else {\n                hasSuccess = true;\n              }\n            }\n          }\n        } else {\n          hasSuccess = true;\n        }\n      };\n\n      return cursorTransaction;\n    },\n\n    /**\n     * Runs a query against the store and passes an array containing matched\n     * objects to the success handler.\n     *\n     * @param {Function} onSuccess A callback to be called when the operation\n     *  was successful.\n     * @param {Object} [options] An object defining specific options\n     * @param {String} [options.index=null] A name of an IDBIndex to operate on\n     * @param {String} [options.order=ASC] The order in which to provide the\n     *  results, can be 'DESC' or 'ASC'\n     * @param {Boolean} [options.filterDuplicates=false] Whether to exclude\n     *  duplicate matches\n     * @param {IDBKeyRange} [options.keyRange=null] An IDBKeyRange to use\n     * @param {Function} [options.onError=throw] A callback to be called\n     *  if an error occurred during the operation.\n     * @param {Number} [options.limit=Infinity] Limit the number of returned\n     *  results to this number\n     * @param {Number} [options.offset=0] Skip the provided number of results\n     *  in the resultset\n     * @param {Function} [options.filter=null] A custom filter function to\n     *  apply to query resuts before returning. Must return `false` to reject\n     *  an item. Can be combined with keyRanges.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    query: function (onSuccess, options) {\n      var result = [],\n          processedItems = 0;\n      options = options || {};\n      options.autoContinue = true;\n      options.writeAccess = false;\n      options.allowItemRejection = !!options.filter;\n\n      options.onEnd = function () {\n        onSuccess(result, processedItems);\n      };\n\n      return this.iterate(function (item) {\n        processedItems++;\n        var accept = options.filter ? options.filter(item) : true;\n\n        if (accept !== false) {\n          result.push(item);\n        }\n\n        return accept;\n      }, options);\n    },\n\n    /**\n     *\n     * Runs a query against the store, but only returns the number of matches\n     * instead of the matches itself.\n     *\n     * @param {Function} onSuccess A callback to be called if the opration\n     *  was successful.\n     * @param {Object} [options] An object defining specific options\n     * @param {String} [options.index=null] A name of an IDBIndex to operate on\n     * @param {IDBKeyRange} [options.keyRange=null] An IDBKeyRange to use\n     * @param {Function} [options.onError=throw] A callback to be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    count: function (onSuccess, options) {\n      options = mixin({\n        index: null,\n        keyRange: null\n      }, options || {});\n      var onError = options.onError || defaultErrorHandler;\n      var hasSuccess = false,\n          result = null;\n      var cursorTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n\n      cursorTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n\n      cursorTransaction.onabort = onError;\n      cursorTransaction.onerror = onError;\n      var cursorTarget = cursorTransaction.objectStore(this.storeName);\n\n      if (options.index) {\n        cursorTarget = cursorTarget.index(options.index);\n      }\n\n      var countRequest = cursorTarget.count(options.keyRange);\n\n      countRequest.onsuccess = function (evt) {\n        hasSuccess = true;\n        result = evt.target.result;\n      };\n\n      countRequest.onError = onError;\n      return cursorTransaction;\n    },\n\n    /**************/\n\n    /* key ranges */\n\n    /**************/\n\n    /**\n     * Creates a key range using specified options. This key range can be\n     * handed over to the count() and iterate() methods.\n     *\n     * Note: You must provide at least one or both of \"lower\" or \"upper\" value.\n     *\n     * @param {Object} options The options for the key range to create\n     * @param {*} [options.lower] The lower bound\n     * @param {Boolean} [options.excludeLower] Whether to exclude the lower\n     *  bound passed in options.lower from the key range\n     * @param {*} [options.upper] The upper bound\n     * @param {Boolean} [options.excludeUpper] Whether to exclude the upper\n     *  bound passed in options.upper from the key range\n     * @param {*} [options.only] A single key value. Use this if you need a key\n     *  range that only includes one value for a key. Providing this\n     *  property invalidates all other properties.\n     * @return {IDBKeyRange} The IDBKeyRange representing the specified options\n     */\n    makeKeyRange: function (options) {\n      /*jshint onecase:true */\n      var keyRange,\n          hasLower = typeof options.lower != 'undefined',\n          hasUpper = typeof options.upper != 'undefined',\n          isOnly = typeof options.only != 'undefined';\n\n      switch (true) {\n        case isOnly:\n          keyRange = this.keyRange.only(options.only);\n          break;\n\n        case hasLower && hasUpper:\n          keyRange = this.keyRange.bound(options.lower, options.upper, options.excludeLower, options.excludeUpper);\n          break;\n\n        case hasLower:\n          keyRange = this.keyRange.lowerBound(options.lower, options.excludeLower);\n          break;\n\n        case hasUpper:\n          keyRange = this.keyRange.upperBound(options.upper, options.excludeUpper);\n          break;\n\n        default:\n          throw new Error('Cannot create KeyRange. Provide one or both of \"lower\" or \"upper\" value, or an \"only\" value.');\n      }\n\n      return keyRange;\n    }\n  };\n  /** helpers **/\n\n  var empty = {};\n\n  function mixin(target, source) {\n    var name, s;\n\n    for (name in source) {\n      s = source[name];\n\n      if (s !== empty[name] && s !== target[name]) {\n        target[name] = s;\n      }\n    }\n\n    return target;\n  }\n\n  function hasVersionError(errorEvent) {\n    if ('error' in errorEvent.target) {\n      return errorEvent.target.error.name == 'VersionError';\n    } else if ('errorCode' in errorEvent.target) {\n      return errorEvent.target.errorCode == 12;\n    }\n\n    return false;\n  }\n\n  IDBStore.prototype = proto;\n  IDBStore.version = proto.version;\n  return IDBStore;\n}, this);","map":null,"metadata":{},"sourceType":"script"}