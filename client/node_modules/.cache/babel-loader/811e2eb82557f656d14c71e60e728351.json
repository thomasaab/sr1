{"ast":null,"code":"var EventEmitter = require('events').EventEmitter;\n\nvar inherits = require('util').inherits;\n\nvar ranges = require('string-range');\n\nvar fixRange = require('level-fix-range');\n\nvar xtend = require('xtend');\n\nvar Batch = require('./batch');\n\ninherits(SubDB, EventEmitter);\n\nfunction SubDB(db, prefix, options) {\n  if ('string' === typeof options) {\n    console.error('db.sublevel(name, seperator<string>) is depreciated');\n    console.error('use db.sublevel(name, {sep: separator})) if you must');\n    options = {\n      sep: options\n    };\n  }\n\n  if (!(this instanceof SubDB)) return new SubDB(db, prefix, options);\n  if (!db) throw new Error('must provide db');\n  if (!prefix) throw new Error('must provide prefix');\n  options = options || {};\n  options.sep = options.sep || '\\xff';\n  this._parent = db;\n  this._options = options;\n  this.options = options;\n  this._prefix = prefix;\n  this._root = root(this);\n  db.sublevels[prefix] = this;\n  this.sublevels = {};\n  this.methods = {};\n  var self = this;\n  this.hooks = {\n    pre: function () {\n      return self.pre.apply(self, arguments);\n    },\n    post: function () {\n      return self.post.apply(self, arguments);\n    }\n  };\n}\n\nvar SDB = SubDB.prototype;\n\nSDB._key = function (key) {\n  var sep = this._options.sep;\n  return sep + this._prefix + sep + key;\n};\n\nSDB._getOptsAndCb = function (opts, cb) {\n  if (typeof opts == 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  return {\n    opts: xtend(opts, this._options),\n    cb: cb\n  };\n};\n\nSDB.sublevel = function (prefix, options) {\n  if (this.sublevels[prefix]) return this.sublevels[prefix];\n  return new SubDB(this, prefix, options || this._options);\n};\n\nSDB.put = function (key, value, opts, cb) {\n  var res = this._getOptsAndCb(opts, cb);\n\n  this._root.put(this.prefix(key), value, res.opts, res.cb);\n};\n\nSDB.get = function (key, opts, cb) {\n  var res = this._getOptsAndCb(opts, cb);\n\n  this._root.get(this.prefix(key), res.opts, res.cb);\n};\n\nSDB.del = function (key, opts, cb) {\n  var res = this._getOptsAndCb(opts, cb);\n\n  this._root.del(this.prefix(key), res.opts, res.cb);\n};\n\nSDB.batch = function (changes, opts, cb) {\n  if (!Array.isArray(changes)) return new Batch(this);\n\n  var self = this,\n      res = this._getOptsAndCb(opts, cb);\n\n  changes.forEach(function (ch) {\n    //OH YEAH, WE NEED TO VALIDATE THAT UPDATING THIS KEY/PREFIX IS ALLOWED\n    if ('string' === typeof ch.prefix) ch.key = ch.prefix + ch.key;else ch.key = (ch.prefix || self).prefix(ch.key);\n    if (ch.prefix) ch.prefix = null;\n  });\n\n  this._root.batch(changes, res.opts, res.cb);\n};\n\nSDB._getKeyEncoding = function () {\n  if (this.options.keyEncoding) return this.options.keyEncoding;\n  if (this._parent && this._parent._getKeyEncoding) return this._parent._getKeyEncoding();\n};\n\nSDB._getValueEncoding = function () {\n  if (this.options.valueEncoding) return this.options.valueEncoding;\n  if (this._parent && this._parent._getValueEncoding) return this._parent._getValueEncoding();\n};\n\nSDB.prefix = function (key) {\n  var sep = this._options.sep;\n  return this._parent.prefix() + sep + this._prefix + sep + (key || '');\n};\n\nSDB.keyStream = SDB.createKeyStream = function (opts) {\n  opts = opts || {};\n  opts.keys = true;\n  opts.values = false;\n  return this.createReadStream(opts);\n};\n\nSDB.valueStream = SDB.createValueStream = function (opts) {\n  opts = opts || {};\n  opts.keys = false;\n  opts.values = true;\n  opts.keys = false;\n  return this.createReadStream(opts);\n};\n\nfunction selectivelyMerge(_opts, opts) {\n  ['valueEncoding', 'encoding', 'keyEncoding', 'reverse', 'values', 'keys', 'limit', 'fillCache'].forEach(function (k) {\n    if (opts.hasOwnProperty(k)) _opts[k] = opts[k];\n  });\n}\n\nSDB.readStream = SDB.createReadStream = function (opts) {\n  opts = opts || {};\n  var r = root(this);\n  var p = this.prefix();\n\n  var _opts = ranges.prefix(opts, p);\n\n  selectivelyMerge(_opts, xtend(opts, this._options));\n  var s = r.createReadStream(_opts);\n\n  if (_opts.values === false) {\n    var read = s.read;\n\n    if (read) {\n      s.read = function (size) {\n        var val = read.call(this, size);\n        if (val) val = val.substring(p.length);\n        return val;\n      };\n    } else {\n      var emit = s.emit;\n\n      s.emit = function (event, val) {\n        if (event === 'data') {\n          emit.call(this, 'data', val.substring(p.length));\n        } else emit.call(this, event, val);\n      };\n    }\n\n    return s;\n  } else if (_opts.keys === false) return s;else {\n    var read = s.read;\n\n    if (read) {\n      s.read = function (size) {\n        var d = read.call(this, size);\n        if (d) d.key = d.key.substring(p.length);\n        return d;\n      };\n    } else {\n      s.on('data', function (d) {\n        //mutate the prefix!\n        //this doesn't work for createKeyStream admittedly.\n        d.key = d.key.substring(p.length);\n      });\n    }\n\n    return s;\n  }\n};\n\nSDB.writeStream = SDB.createWriteStream = function () {\n  var r = root(this);\n  var p = this.prefix();\n  var ws = r.createWriteStream.apply(r, arguments);\n  var write = ws.write;\n  var encoding = this._options.encoding;\n  var valueEncoding = this._options.valueEncoding;\n  var keyEncoding = this._options.keyEncoding; // slight optimization, if no encoding was specified at all,\n  // which will be the case most times, make write not check at all\n\n  var nocheck = !encoding && !valueEncoding && !keyEncoding;\n  ws.write = nocheck ? function (data) {\n    data.key = p + data.key;\n    return write.call(ws, data);\n  } : function (data) {\n    data.key = p + data.key; // not merging all options here since this happens on every write and things could get slowed down\n    // at this point we only consider encoding important to propagate\n\n    if (encoding && typeof data.encoding === 'undefined') data.encoding = encoding;\n    if (valueEncoding && typeof data.valueEncoding === 'undefined') data.valueEncoding = valueEncoding;\n    if (keyEncoding && typeof data.keyEncoding === 'undefined') data.keyEncoding = keyEncoding;\n    return write.call(ws, data);\n  };\n  return ws;\n};\n\nSDB.approximateSize = function () {\n  var r = root(db);\n  return r.approximateSize.apply(r, arguments);\n};\n\nfunction root(db) {\n  if (!db._parent) return db;\n  return root(db._parent);\n}\n\nSDB.pre = function (range, hook) {\n  if (!hook) hook = range, range = null;\n  range = ranges.prefix(range, this.prefix(), this._options.sep);\n  var r = root(this._parent);\n  var p = this.prefix();\n  return r.hooks.pre(fixRange(range), function (ch, add, batch) {\n    hook({\n      key: ch.key.substring(p.length),\n      value: ch.value,\n      type: ch.type\n    }, function (ch, _p) {\n      //maybe remove the second add arg now\n      //that op can have prefix?\n      add(ch, ch.prefix ? _p : _p || p);\n    }, batch);\n  });\n};\n\nSDB.post = function (range, hook) {\n  if (!hook) hook = range, range = null;\n  var r = root(this._parent);\n  var p = this.prefix();\n  range = ranges.prefix(range, p, this._options.sep);\n  return r.hooks.post(fixRange(range), function (data) {\n    hook({\n      key: data.key.substring(p.length),\n      value: data.value,\n      type: data.type\n    });\n  });\n};\n\nvar exports = module.exports = SubDB;","map":null,"metadata":{},"sourceType":"script"}