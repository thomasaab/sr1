{"ast":null,"code":"var fwd = require('fwd-stream');\n\nvar sublevel = require('level-sublevel');\n\nvar blobs = require('level-blobs');\n\nvar peek = require('level-peek');\n\nvar once = require('once');\n\nvar octal = require('octal');\n\nvar errno = require('./errno');\n\nvar paths = require('./paths');\n\nvar watchers = require('./watchers');\n\nvar nextTick = function (cb, err, val) {\n  process.nextTick(function () {\n    cb(err, val);\n  });\n};\n\nvar noop = function () {};\n\nmodule.exports = function (db, opts) {\n  var fs = {};\n  db = sublevel(db);\n  var bl = blobs(db.sublevel('blobs'), opts);\n  var ps = paths(db.sublevel('stats'));\n  var links = db.sublevel('links');\n  var listeners = watchers();\n  var fds = [];\n  var now = Date.now();\n\n  var inc = function () {\n    return ++now;\n  };\n\n  fs.mkdir = function (key, mode, cb) {\n    if (typeof mode === 'function') return fs.mkdir(key, null, mode);\n    if (!mode) mode = octal(777);\n    if (!cb) cb = noop;\n    ps.follow(key, function (err, stat, key) {\n      if (err && err.code !== 'ENOENT') return cb(err);\n      if (stat) return cb(errno.EEXIST(key));\n      ps.put(key, {\n        type: 'directory',\n        mode: mode,\n        size: 4096\n      }, listeners.cb(key, cb));\n    });\n  };\n\n  fs.rmdir = function (key, cb) {\n    if (!cb) cb = noop;\n    ps.follow(key, function (err, stat, key) {\n      if (err) return cb(err);\n      fs.readdir(key, function (err, files) {\n        if (err) return cb(err);\n        if (files.length) return cb(errno.ENOTEMPTY(key));\n        ps.del(key, listeners.cb(key, cb));\n      });\n    });\n  };\n\n  fs.readdir = function (key, cb) {\n    ps.follow(key, function (err, stat, key) {\n      if (err) return cb(err);\n      if (!stat) return cb(errno.ENOENT(key));\n      if (!stat.isDirectory()) return cb(errno.ENOTDIR(key));\n      ps.list(key, cb);\n    });\n  };\n\n  var stat = function (key, lookup, cb) {\n    lookup(key, function (err, stat, key) {\n      if (err) return cb(err);\n      if (!stat.isFile()) return cb(null, stat);\n      var blob = stat && stat.blob || key;\n      bl.size(blob, function (err, size) {\n        if (err) return cb(err);\n        stat.size = size;\n        cb(null, stat);\n      });\n    });\n  };\n\n  fs.stat = function (key, cb) {\n    stat(key, ps.follow, cb);\n  };\n\n  fs.lstat = function (key, cb) {\n    stat(key, ps.get, cb);\n  };\n\n  fs.exists = function (key, cb) {\n    ps.follow(key, function (err) {\n      cb(!err);\n    });\n  };\n\n  var chmod = function (key, lookup, mode, cb) {\n    if (!cb) cb = noop;\n    lookup(key, function (err, stat, key) {\n      if (err) return cb(err);\n      ps.update(key, {\n        mode: mode\n      }, listeners.cb(key, cb));\n    });\n  };\n\n  fs.chmod = function (key, mode, cb) {\n    chmod(key, ps.follow, mode, cb);\n  };\n\n  fs.lchmod = function (key, mode, cb) {\n    chmod(key, ps.get, mode, cb);\n  };\n\n  var chown = function (key, lookup, uid, gid, cb) {\n    if (!cb) cb = noop;\n    lookup(key, function (err, stat, key) {\n      if (err) return cb(err);\n      ps.update(key, {\n        uid: uid,\n        gid: gid\n      }, listeners.cb(key, cb));\n    });\n  };\n\n  fs.chown = function (key, uid, gid, cb) {\n    chown(key, ps.follow, uid, gid, cb);\n  };\n\n  fs.lchown = function (key, uid, gid, cb) {\n    chown(key, ps.get, uid, gid, cb);\n  };\n\n  fs.utimes = function (key, atime, mtime, cb) {\n    if (!cb) cb = noop;\n    ps.follow(key, function (err, stat, key) {\n      if (err) return cb(err);\n      var upd = {};\n      if (atime) upd.atime = atime;\n      if (mtime) upd.mtime = mtime;\n      ps.update(key, upd, listeners.cb(key, cb));\n    });\n  };\n\n  fs.rename = function (from, to, cb) {\n    if (!cb) cb = noop;\n    ps.follow(from, function (err, statFrom, from) {\n      if (err) return cb(err);\n\n      var rename = function () {\n        cb = listeners.cb(to, listeners.cb(from, cb));\n        ps.put(to, statFrom, function (err) {\n          if (err) return cb(err);\n          ps.del(from, cb);\n        });\n      };\n\n      ps.follow(to, function (err, statTo, to) {\n        if (err && err.code !== 'ENOENT') return cb(err);\n        if (!statTo) return rename();\n        if (statFrom.isDirectory() !== statTo.isDirectory()) return cb(errno.EISDIR(from));\n\n        if (statTo.isDirectory()) {\n          fs.readdir(to, function (err, list) {\n            if (err) return cb(err);\n            if (list.length) return cb(errno.ENOTEMPTY(from));\n            rename();\n          });\n          return;\n        }\n\n        rename();\n      });\n    });\n  };\n\n  fs.realpath = function (key, cache, cb) {\n    if (typeof cache === 'function') return fs.realpath(key, null, cache);\n    ps.follow(key, function (err, stat, key) {\n      if (err) return cb(err);\n      cb(null, key);\n    });\n  };\n\n  fs.writeFile = function (key, data, opts, cb) {\n    if (typeof opts === 'function') return fs.writeFile(key, data, null, opts);\n    if (typeof opts === 'string') opts = {\n      encoding: opts\n    };\n    if (!opts) opts = {};\n    if (!cb) cb = noop;\n    if (!Buffer.isBuffer(data)) data = new Buffer(data, opts.encoding || 'utf-8');\n    var flags = opts.flags || 'w';\n    opts.append = flags[0] !== 'w';\n    ps.follow(key, function (err, stat, key) {\n      if (err && err.code !== 'ENOENT') return cb(err);\n      if (stat && stat.isDirectory()) return cb(errno.EISDIR(key));\n      if (stat && flags[1] === 'x') return cb(errno.EEXIST(key));\n      var blob = stat && stat.blob || key;\n      ps.writable(key, function (err) {\n        if (err) return cb(err);\n        bl.write(blob, data, opts, function (err) {\n          if (err) return cb(err);\n          ps.put(key, {\n            ctime: stat && stat.ctime,\n            mtime: new Date(),\n            mode: opts.mode || octal(666),\n            type: 'file'\n          }, listeners.cb(key, cb));\n        });\n      });\n    });\n  };\n\n  fs.appendFile = function (key, data, opts, cb) {\n    if (typeof opts === 'function') return fs.appendFile(key, data, null, opts);\n    if (typeof opts === 'string') opts = {\n      encoding: opts\n    };\n    if (!opts) opts = {};\n    opts.flags = 'a';\n    fs.writeFile(key, data, opts, cb);\n  };\n\n  fs.unlink = function (key, cb) {\n    if (!cb) cb = noop;\n    ps.get(key, function (err, stat, key) {\n      if (err) return cb(err);\n      if (stat.isDirectory()) return cb(errno.EISDIR(key));\n\n      var clean = function (target) {\n        peek(links, {\n          start: target + '\\xff',\n          end: target + '\\xff\\xff'\n        }, function (err) {\n          if (err) return bl.remove(target, cb); // no more links\n\n          cb();\n        });\n      };\n\n      var onlink = function () {\n        var target = stat.link.slice(0, stat.link.indexOf('\\xff'));\n        links.del(stat.link, function (err) {\n          if (err) return cb(err);\n          clean(target);\n        });\n      };\n\n      ps.del(key, listeners.cb(key, function (err) {\n        if (err) return cb(err);\n        if (stat.link) return onlink();\n        links.del(key + '\\xff', function (err) {\n          if (err) return cb(err);\n          clean(key);\n        });\n      }));\n    });\n  };\n\n  fs.readFile = function (key, opts, cb) {\n    if (typeof opts === 'function') return fs.readFile(key, null, opts);\n    if (typeof opts === 'string') opts = {\n      encoding: opts\n    };\n    if (!opts) opts = {};\n    var encoding = opts.encoding || 'binary';\n    var flag = opts.flag || 'r';\n    ps.follow(key, function (err, stat, key) {\n      if (err) return cb(err);\n      if (stat.isDirectory()) return cb(errno.EISDIR(key));\n      var blob = stat && stat.blob || key;\n      bl.read(blob, function (err, data) {\n        if (err) return cb(err);\n        cb(null, opts.encoding ? data.toString(opts.encoding) : data);\n      });\n    });\n  };\n\n  fs.createReadStream = function (key, opts) {\n    if (!opts) opts = {};\n    var closed = false;\n    var rs = fwd.readable(function (cb) {\n      ps.follow(key, function (err, stat, key) {\n        if (err) return cb(err);\n        if (stat.isDirectory()) return cb(errno.EISDIR(key));\n        var blob = stat && stat.blob || key;\n        var r = bl.createReadStream(blob, opts);\n        rs.emit('open');\n        r.on('end', function () {\n          process.nextTick(function () {\n            if (!closed) rs.emit('close');\n          });\n        });\n        cb(null, r);\n      });\n    });\n    rs.on('close', function () {\n      closed = true;\n    });\n    return rs;\n  };\n\n  fs.createWriteStream = function (key, opts) {\n    if (!opts) opts = {};\n    var flags = opts.flags || 'w';\n    var closed = false;\n    var mode = opts.mode || octal(666);\n    opts.append = flags[0] === 'a';\n    var ws = fwd.writable(function (cb) {\n      ps.follow(key, function (err, stat, key) {\n        if (err && err.code !== 'ENOENT') return cb(err);\n        if (stat && stat.isDirectory()) return cb(errno.EISDIR(key));\n        if (stat && flags[1] === 'x') return cb(errno.EEXIST(key));\n        var blob = stat && stat.blob || key;\n        ps.writable(blob, function (err) {\n          if (err) return cb(err);\n          var ctime = stat ? stat.ctime : new Date();\n          var s = {\n            ctime: ctime,\n            mtime: new Date(),\n            mode: mode,\n            type: 'file'\n          };\n          ps.put(key, s, function (err) {\n            if (err) return cb(err);\n            var w = bl.createWriteStream(blob, opts);\n            ws.emit('open');\n            w.on('finish', function () {\n              s.mtime = new Date();\n              ps.put(key, s, function () {\n                listeners.change(key);\n                if (!closed) ws.emit('close');\n              });\n            });\n            cb(null, w);\n          });\n        });\n      });\n    });\n    ws.on('close', function () {\n      closed = true;\n    });\n    return ws;\n  };\n\n  fs.truncate = function (key, len, cb) {\n    ps.follow(key, function (err, stat, key) {\n      if (err) return cb(err);\n      var blob = stat && stat.blob || key;\n      bl.size(blob, function (err, size) {\n        if (err) return cb(err);\n        ps.writable(key, function (err) {\n          if (err) return cb(err);\n          cb = once(listeners.cb(key, cb));\n          if (!len) return bl.remove(blob, cb);\n          var ws = bl.createWriteStream(blob, {\n            start: size < len ? len - 1 : len\n          });\n          ws.on('error', cb);\n          ws.on('finish', cb);\n          if (size < len) ws.write(new Buffer([0]));\n          ws.end();\n        });\n      });\n    });\n  };\n\n  fs.watchFile = function (key, opts, cb) {\n    if (typeof opts === 'function') return fs.watchFile(key, null, opts);\n    return listeners.watch(ps.normalize(key), cb);\n  };\n\n  fs.unwatchFile = function (key, cb) {\n    listeners.unwatch(ps.normalize(key), cb);\n  };\n\n  fs.watch = function (key, opts, cb) {\n    if (typeof opts === 'function') return fs.watch(key, null, opts);\n    return listeners.watcher(ps.normalize(key), cb);\n  };\n\n  fs.notify = function (cb) {\n    listeners.on('change', cb);\n  };\n\n  fs.open = function (key, flags, mode, cb) {\n    if (typeof mode === 'function') return fs.open(key, flags, null, mode);\n    ps.follow(key, function (err, stat, key) {\n      if (err && err.code !== 'ENOENT') return cb(err);\n      var fl = flags[0];\n      var plus = flags[1] === '+' || flags[2] === '+';\n      var blob = stat && stat.blob || key;\n      var f = {\n        key: key,\n        blob: blob,\n        mode: mode || octal(666),\n        readable: fl === 'r' || (fl === 'w' || fl === 'a') && plus,\n        writable: fl === 'w' || fl === 'a' || fl === 'r' && plus,\n        append: fl === 'a'\n      };\n      if (fl === 'r' && err) return cb(err);\n      if (flags[1] === 'x' && stat) return cb(errno.EEXIST(key));\n      if (stat && stat.isDirectory()) return cb(errno.EISDIR(key));\n      bl.size(blob, function (err, size) {\n        if (err) return cb(err);\n        if (f.append) f.writePos = size;\n        ps.writable(key, function (err) {\n          if (err) return cb(err);\n\n          var onready = function (err) {\n            if (err) return cb(err);\n            var i = fds.indexOf(null);\n            if (i === -1) i = 10 + fds.push(fds.length + 10) - 1;\n            f.fd = i;\n            fds[i] = f;\n            listeners.change(key);\n            cb(null, f.fd);\n          };\n\n          var ontruncate = function (err) {\n            if (err) return cb(err);\n            if (stat) return onready();\n            ps.put(blob, {\n              ctime: stat && stat.ctime,\n              type: 'file'\n            }, onready);\n          };\n\n          if (!f.append && f.writable) return bl.remove(blob, ontruncate);\n          ontruncate();\n        });\n      });\n    });\n  };\n\n  fs.close = function (fd, cb) {\n    var f = fds[fd];\n    if (!f) return nextTick(cb, errno.EBADF());\n    fds[fd] = null;\n    nextTick(listeners.cb(f.key, cb));\n  };\n\n  fs.write = function (fd, buf, off, len, pos, cb) {\n    var f = fds[fd];\n    if (!cb) cb = noop;\n    if (!f || !f.writable) return nextTick(cb, errno.EBADF());\n    if (pos === null) pos = f.writePos || 0;\n    var slice = buf.slice(off, off + len);\n    f.writePos = pos + slice.length;\n    bl.write(f.blob, slice, {\n      start: pos,\n      append: true\n    }, function (err) {\n      if (err) return cb(err);\n      cb(null, len, buf);\n    });\n  };\n\n  fs.read = function (fd, buf, off, len, pos, cb) {\n    var f = fds[fd];\n    if (!cb) cb = noop;\n    if (!f || !f.readable) return nextTick(cb, errno.EBADF());\n    if (pos === null) pos = fs.readPos || 0;\n    bl.read(f.blob, {\n      start: pos,\n      end: pos + len - 1\n    }, function (err, read) {\n      if (err) return cb(err);\n      var slice = read.slice(0, len);\n      slice.copy(buf, off);\n      fs.readPos = pos + slice.length;\n      cb(null, slice.length, buf);\n    });\n  };\n\n  fs.fsync = function (fd, cb) {\n    var f = fds[fd];\n    if (!cb) cb = noop;\n    if (!f || !f.writable) return nextTick(cb, errno.EBADF());\n    nextTick(cb);\n  };\n\n  fs.ftruncate = function (fd, len, cb) {\n    var f = fds[fd];\n    if (!cb) cb = noop;\n    if (!f) return nextTick(cb, errno.EBADF());\n    fs.truncate(f.blob, len, cb);\n  };\n\n  fs.fchown = function (fd, uid, gid, cb) {\n    var f = fds[fd];\n    if (!cb) cb = noop;\n    if (!f) return nextTick(cb, errno.EBADF());\n    fs.chown(f.key, uid, gid, cb);\n  };\n\n  fs.fchmod = function (fd, mode, cb) {\n    var f = fds[fd];\n    if (!cb) cb = noop;\n    if (!f) return nextTick(cb, errno.EBADF());\n    fs.chmod(f.key, mode, cb);\n  };\n\n  fs.futimes = function (fd, atime, mtime, cb) {\n    var f = fds[fd];\n    if (!cb) cb = noop;\n    if (!f) return nextTick(cb, errno.EBADF());\n    fs.utimes(f.key, atime, mtime, cb);\n  };\n\n  fs.fstat = function (fd, cb) {\n    var f = fds[fd];\n    if (!f) return nextTick(cb, errno.EBADF());\n    fs.stat(f.key, cb);\n  };\n\n  fs.symlink = function (target, name, cb) {\n    if (!cb) cb = noop;\n    ps.follow(target, function (err, stat, target) {\n      if (err) return cb(err);\n      ps.get(name, function (err, stat) {\n        if (err && err.code !== 'ENOENT') return cb(err);\n        if (stat) return cb(errno.EEXIST(name));\n        ps.put(name, {\n          type: 'symlink',\n          target: target,\n          mode: octal(777)\n        }, cb);\n      });\n    });\n  };\n\n  fs.readlink = function (key, cb) {\n    ps.get(key, function (err, stat) {\n      if (err) return cb(err);\n      if (!stat.target) return cb(errno.EINVAL(key));\n      cb(null, stat.target);\n    });\n  };\n\n  fs.link = function (target, name, cb) {\n    if (!cb) cb = noop;\n    ps.follow(target, function (err, stat, target) {\n      if (err) return cb(err);\n      if (!stat.isFile()) return cb(errno.EINVAL(target));\n      ps.get(name, function (err, st) {\n        if (err && err.code !== 'ENOENT') return cb(err);\n        if (st) return cb(errno.EEXIST(name));\n        var link = target + '\\xff' + inc();\n        links.put(target + '\\xff', target, function (err) {\n          if (err) return cb(err);\n          links.put(link, target, function (err) {\n            if (err) return cb(err);\n            ps.put(name, {\n              type: 'file',\n              link: link,\n              blob: target,\n              mode: stat.mode\n            }, cb);\n          });\n        });\n      });\n    });\n  };\n\n  return fs;\n};","map":null,"metadata":{},"sourceType":"script"}