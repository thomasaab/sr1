{"ast":null,"code":"var util = require('util');\n\nvar AbstractIterator = require('abstract-leveldown').AbstractIterator;\n\nvar ltgt = require('ltgt');\n\nmodule.exports = Iterator;\n\nfunction Iterator(db, options) {\n  if (!options) options = {};\n  this.options = options;\n  AbstractIterator.call(this, db);\n  this._order = options.reverse ? 'DESC' : 'ASC';\n  this._limit = options.limit;\n  this._count = 0;\n  this._done = false;\n  var lower = ltgt.lowerBound(options);\n  var upper = ltgt.upperBound(options);\n\n  try {\n    this._keyRange = lower || upper ? this.db.makeKeyRange({\n      lower: lower,\n      upper: upper,\n      excludeLower: ltgt.lowerBoundExclusive(options),\n      excludeUpper: ltgt.upperBoundExclusive(options)\n    }) : null;\n  } catch (e) {\n    // The lower key is greater than the upper key.\n    // IndexedDB throws an error, but we'll just return 0 results.\n    this._keyRangeError = true;\n  }\n\n  this.callback = null;\n}\n\nutil.inherits(Iterator, AbstractIterator);\n\nIterator.prototype.createIterator = function () {\n  var self = this;\n  self.iterator = self.db.iterate(function () {\n    self.onItem.apply(self, arguments);\n  }, {\n    keyRange: self._keyRange,\n    autoContinue: false,\n    order: self._order,\n    onError: function (err) {\n      console.log('horrible error', err);\n    }\n  });\n}; // TODO the limit implementation here just ignores all reads after limit has been reached\n// it should cancel the iterator instead but I don't know how\n\n\nIterator.prototype.onItem = function (value, cursor, cursorTransaction) {\n  if (!cursor && this.callback) {\n    this.callback();\n    this.callback = false;\n    return;\n  }\n\n  var shouldCall = true;\n  if (!!this._limit && this._limit > 0 && this._count++ >= this._limit) shouldCall = false;\n  if (shouldCall) this.callback(false, cursor.key, cursor.value);\n  if (cursor) cursor['continue']();\n};\n\nIterator.prototype._next = function (callback) {\n  if (!callback) return new Error('next() requires a callback argument');\n  if (this._keyRangeError) return callback();\n\n  if (!this._started) {\n    this.createIterator();\n    this._started = true;\n  }\n\n  this.callback = callback;\n};","map":null,"metadata":{},"sourceType":"script"}