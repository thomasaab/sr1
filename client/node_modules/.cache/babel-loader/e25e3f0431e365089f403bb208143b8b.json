{"ast":null,"code":"module.exports = Level;\n\nvar IDB = require('idb-wrapper');\n\nvar AbstractLevelDOWN = require('abstract-leveldown').AbstractLevelDOWN;\n\nvar util = require('util');\n\nvar Iterator = require('./iterator');\n\nvar isBuffer = require('isbuffer');\n\nvar xtend = require('xtend');\n\nvar toBuffer = require('typedarray-to-buffer');\n\nfunction Level(location) {\n  if (!(this instanceof Level)) return new Level(location);\n  if (!location) throw new Error(\"constructor requires at least a location argument\");\n  this.IDBOptions = {};\n  this.location = location;\n}\n\nutil.inherits(Level, AbstractLevelDOWN);\n\nLevel.prototype._open = function (options, callback) {\n  var self = this;\n  var idbOpts = {\n    storeName: this.location,\n    autoIncrement: false,\n    keyPath: null,\n    onStoreReady: function () {\n      callback && callback(null, self.idb);\n    },\n    onError: function (err) {\n      callback && callback(err);\n    }\n  };\n  xtend(idbOpts, options);\n  this.IDBOptions = idbOpts;\n  this.idb = new IDB(idbOpts);\n};\n\nLevel.prototype._get = function (key, options, callback) {\n  this.idb.get(key, function (value) {\n    if (value === undefined) {\n      // 'NotFound' error, consistent with LevelDOWN API\n      return callback(new Error('NotFound'));\n    } // by default return buffers, unless explicitly told not to\n\n\n    var asBuffer = true;\n    if (options.asBuffer === false) asBuffer = false;\n    if (options.raw) asBuffer = false;\n\n    if (asBuffer) {\n      if (value instanceof Uint8Array) value = toBuffer(value);else value = new Buffer(String(value));\n    }\n\n    return callback(null, value, key);\n  }, callback);\n};\n\nLevel.prototype._del = function (id, options, callback) {\n  this.idb.remove(id, callback, callback);\n};\n\nLevel.prototype._put = function (key, value, options, callback) {\n  if (value instanceof ArrayBuffer) {\n    value = toBuffer(new Uint8Array(value));\n  }\n\n  var obj = this.convertEncoding(key, value, options);\n\n  if (Buffer.isBuffer(obj.value)) {\n    if (typeof value.toArrayBuffer === 'function') {\n      obj.value = new Uint8Array(value.toArrayBuffer());\n    } else {\n      obj.value = new Uint8Array(value);\n    }\n  }\n\n  this.idb.put(obj.key, obj.value, function () {\n    callback();\n  }, callback);\n};\n\nLevel.prototype.convertEncoding = function (key, value, options) {\n  if (options.raw) return {\n    key: key,\n    value: value\n  };\n\n  if (value) {\n    var stringed = value.toString();\n    if (stringed === 'NaN') value = 'NaN';\n  }\n\n  var valEnc = options.valueEncoding;\n  var obj = {\n    key: key,\n    value: value\n  };\n\n  if (value && (!valEnc || valEnc !== 'binary')) {\n    if (typeof obj.value !== 'object') {\n      obj.value = stringed;\n    }\n  }\n\n  return obj;\n};\n\nLevel.prototype.iterator = function (options) {\n  if (typeof options !== 'object') options = {};\n  return new Iterator(this.idb, options);\n};\n\nLevel.prototype._batch = function (array, options, callback) {\n  var op;\n  var i;\n  var k;\n  var copiedOp;\n  var currentOp;\n  var modified = [];\n  if (array.length === 0) return setTimeout(callback, 0);\n\n  for (i = 0; i < array.length; i++) {\n    copiedOp = {};\n    currentOp = array[i];\n    modified[i] = copiedOp;\n    var converted = this.convertEncoding(currentOp.key, currentOp.value, options);\n    currentOp.key = converted.key;\n    currentOp.value = converted.value;\n\n    for (k in currentOp) {\n      if (k === 'type' && currentOp[k] == 'del') {\n        copiedOp[k] = 'remove';\n      } else {\n        copiedOp[k] = currentOp[k];\n      }\n    }\n  }\n\n  return this.idb.batch(modified, function () {\n    callback();\n  }, callback);\n};\n\nLevel.prototype._close = function (callback) {\n  this.idb.db.close();\n  callback();\n};\n\nLevel.prototype._approximateSize = function (start, end, callback) {\n  var err = new Error('Not implemented');\n  if (callback) return callback(err);\n  throw err;\n};\n\nLevel.prototype._isBuffer = function (obj) {\n  return Buffer.isBuffer(obj);\n};\n\nLevel.destroy = function (db, callback) {\n  if (typeof db === 'object') {\n    var prefix = db.IDBOptions.storePrefix || 'IDBWrapper-';\n    var dbname = db.location;\n  } else {\n    var prefix = 'IDBWrapper-';\n    var dbname = db;\n  }\n\n  var request = indexedDB.deleteDatabase(prefix + dbname);\n\n  request.onsuccess = function () {\n    callback();\n  };\n\n  request.onerror = function (err) {\n    callback(err);\n  };\n};\n\nvar checkKeyValue = Level.prototype._checkKeyValue = function (obj, type) {\n  if (obj === null || obj === undefined) return new Error(type + ' cannot be `null` or `undefined`');\n  if (obj === null || obj === undefined) return new Error(type + ' cannot be `null` or `undefined`');\n  if (isBuffer(obj) && obj.byteLength === 0) return new Error(type + ' cannot be an empty ArrayBuffer');\n  if (String(obj) === '') return new Error(type + ' cannot be an empty String');\n  if (obj.length === 0) return new Error(type + ' cannot be an empty Array');\n};","map":null,"metadata":{},"sourceType":"script"}