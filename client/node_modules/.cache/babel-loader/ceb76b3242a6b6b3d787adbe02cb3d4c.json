{"ast":null,"code":"/* Copyright (c) 2012-2014 LevelUP contributors\n * See list at <https://github.com/rvagg/node-levelup#contributing>\n * MIT License <https://github.com/rvagg/node-levelup/blob/master/LICENSE.md>\n */\n// NOTE: we are fixed to readable-stream@1.0.x for now\n// for pure Streams2 across Node versions\nvar Readable = require('readable-stream').Readable,\n    inherits = require('util').inherits,\n    extend = require('xtend'),\n    EncodingError = require('./errors').EncodingError,\n    util = require('./util'),\n    defaultOptions = {\n  keys: true,\n  values: true\n},\n    makeKeyValueData = function (key, value) {\n  return {\n    key: util.decodeKey(key, this._options),\n    value: util.decodeValue(value, this._options)\n  };\n},\n    makeKeyData = function (key) {\n  return util.decodeKey(key, this._options);\n},\n    makeValueData = function (_, value) {\n  return util.decodeValue(value, this._options);\n},\n    makeNoData = function () {\n  return null;\n};\n\nfunction ReadStream(options, db, iteratorFactory) {\n  if (!(this instanceof ReadStream)) return new ReadStream(options, db, iteratorFactory);\n  Readable.call(this, {\n    objectMode: true,\n    highWaterMark: options.highWaterMark\n  }); // purely to keep `db` around until we're done so it's not GCed if the user doesn't keep a ref\n\n  this._db = db;\n  options = this._options = extend(defaultOptions, options);\n  this._keyEncoding = options.keyEncoding || options.encoding;\n  this._valueEncoding = options.valueEncoding || options.encoding;\n  if (typeof this._options.start != 'undefined') this._options.start = util.encodeKey(this._options.start, this._options);\n  if (typeof this._options.end != 'undefined') this._options.end = util.encodeKey(this._options.end, this._options);\n  if (typeof this._options.limit != 'number') this._options.limit = -1;\n  this._options.keyAsBuffer = util.isKeyAsBuffer(this._options);\n  this._options.valueAsBuffer = util.isValueAsBuffer(this._options);\n  this._makeData = this._options.keys && this._options.values ? makeKeyValueData : this._options.keys ? makeKeyData : this._options.values ? makeValueData : makeNoData;\n  var self = this;\n\n  if (!this._db.isOpen()) {\n    this._db.once('ready', function () {\n      if (!self._destroyed) {\n        self._iterator = iteratorFactory(self._options);\n      }\n    });\n  } else this._iterator = iteratorFactory(this._options);\n}\n\ninherits(ReadStream, Readable);\n\nReadStream.prototype._read = function read() {\n  var self = this;\n\n  if (!self._db.isOpen()) {\n    return self._db.once('ready', function () {\n      read.call(self);\n    });\n  }\n\n  if (self._destroyed) return;\n\n  self._iterator.next(function (err, key, value) {\n    if (err || key === undefined && value === undefined) {\n      if (!err && !self._destroyed) self.push(null);\n      return self._cleanup(err);\n    }\n\n    try {\n      value = self._makeData(key, value);\n    } catch (e) {\n      return self._cleanup(new EncodingError(e));\n    }\n\n    if (!self._destroyed) self.push(value);\n  });\n};\n\nReadStream.prototype._cleanup = function (err) {\n  if (this._destroyed) return;\n  this._destroyed = true;\n  var self = this;\n  if (err) self.emit('error', err);\n\n  if (self._iterator) {\n    self._iterator.end(function () {\n      self._iterator = null;\n      self.emit('close');\n    });\n  } else {\n    self.emit('close');\n  }\n};\n\nReadStream.prototype.destroy = function () {\n  this._cleanup();\n};\n\nReadStream.prototype.toString = function () {\n  return 'LevelUP.ReadStream';\n};\n\nmodule.exports = ReadStream;","map":null,"metadata":{},"sourceType":"script"}