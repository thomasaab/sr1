{"ast":null,"code":"/* Copyright (c) 2012-2014 LevelUP contributors\n * See list at <https://github.com/rvagg/node-levelup#contributing>\n * MIT License\n * <https://github.com/rvagg/node-levelup/blob/master/LICENSE.md>\n */\nvar EventEmitter = require('events').EventEmitter,\n    inherits = require('util').inherits,\n    extend = require('xtend'),\n    prr = require('prr'),\n    DeferredLevelDOWN = require('deferred-leveldown'),\n    WriteError = require('./errors').WriteError,\n    ReadError = require('./errors').ReadError,\n    NotFoundError = require('./errors').NotFoundError,\n    OpenError = require('./errors').OpenError,\n    EncodingError = require('./errors').EncodingError,\n    InitializationError = require('./errors').InitializationError,\n    ReadStream = require('./read-stream'),\n    WriteStream = require('./write-stream'),\n    util = require('./util'),\n    Batch = require('./batch'),\n    getOptions = util.getOptions,\n    defaultOptions = util.defaultOptions,\n    getLevelDOWN = util.getLevelDOWN,\n    dispatchError = util.dispatchError;\n\nfunction getCallback(options, callback) {\n  return typeof options == 'function' ? options : callback;\n} // Possible LevelUP#_status values:\n//  - 'new'     - newly created, not opened or closed\n//  - 'opening' - waiting for the database to be opened, post open()\n//  - 'open'    - successfully opened the database, available for use\n//  - 'closing' - waiting for the database to be closed, post close()\n//  - 'closed'  - database has been successfully closed, should not be\n//                 used except for another open() operation\n\n\nfunction LevelUP(location, options, callback) {\n  if (!(this instanceof LevelUP)) return new LevelUP(location, options, callback);\n  var error;\n  EventEmitter.call(this);\n  this.setMaxListeners(Infinity);\n\n  if (typeof location == 'function') {\n    options = typeof options == 'object' ? options : {};\n    options.db = location;\n    location = null;\n  } else if (typeof location == 'object' && typeof location.db == 'function') {\n    options = location;\n    location = null;\n  }\n\n  if (typeof options == 'function') {\n    callback = options;\n    options = {};\n  }\n\n  if ((!options || typeof options.db != 'function') && typeof location != 'string') {\n    error = new InitializationError('Must provide a location for the database');\n\n    if (callback) {\n      return process.nextTick(function () {\n        callback(error);\n      });\n    }\n\n    throw error;\n  }\n\n  options = getOptions(this, options);\n  this.options = extend(defaultOptions, options);\n  this._status = 'new'; // set this.location as enumerable but not configurable or writable\n\n  prr(this, 'location', location, 'e');\n  this.open(callback);\n}\n\ninherits(LevelUP, EventEmitter);\n\nLevelUP.prototype.open = function (callback) {\n  var self = this,\n      dbFactory,\n      db;\n\n  if (this.isOpen()) {\n    if (callback) process.nextTick(function () {\n      callback(null, self);\n    });\n    return this;\n  }\n\n  if (this._isOpening()) {\n    return callback && this.once('open', function () {\n      callback(null, self);\n    });\n  }\n\n  this.emit('opening');\n  this._status = 'opening';\n  this.db = new DeferredLevelDOWN(this.location);\n  dbFactory = this.options.db || getLevelDOWN();\n  db = dbFactory(this.location);\n  db.open(this.options, function (err) {\n    if (err) {\n      return dispatchError(self, new OpenError(err), callback);\n    } else {\n      self.db.setDb(db);\n      self.db = db;\n      self._status = 'open';\n      if (callback) callback(null, self);\n      self.emit('open');\n      self.emit('ready');\n    }\n  });\n};\n\nLevelUP.prototype.close = function (callback) {\n  var self = this;\n\n  if (this.isOpen()) {\n    this._status = 'closing';\n    this.db.close(function () {\n      self._status = 'closed';\n      self.emit('closed');\n      if (callback) callback.apply(null, arguments);\n    });\n    this.emit('closing');\n    this.db = null;\n  } else if (this._status == 'closed' && callback) {\n    return process.nextTick(callback);\n  } else if (this._status == 'closing' && callback) {\n    this.once('closed', callback);\n  } else if (this._isOpening()) {\n    this.once('open', function () {\n      self.close(callback);\n    });\n  }\n};\n\nLevelUP.prototype.isOpen = function () {\n  return this._status == 'open';\n};\n\nLevelUP.prototype._isOpening = function () {\n  return this._status == 'opening';\n};\n\nLevelUP.prototype.isClosed = function () {\n  return /^clos/.test(this._status);\n};\n\nLevelUP.prototype.get = function (key_, options, callback) {\n  var self = this,\n      key;\n  callback = getCallback(options, callback);\n\n  if (typeof callback != 'function') {\n    return dispatchError(this, new ReadError('get() requires key and callback arguments'));\n  }\n\n  if (!this._isOpening() && !this.isOpen()) {\n    return dispatchError(this, new ReadError('Database is not open'), callback);\n  }\n\n  options = util.getOptions(this, options);\n  key = util.encodeKey(key_, options);\n  options.asBuffer = util.isValueAsBuffer(options);\n  this.db.get(key, options, function (err, value) {\n    if (err) {\n      if (/notfound/i.test(err)) {\n        err = new NotFoundError('Key not found in database [' + key_ + ']', err);\n      } else {\n        err = new ReadError(err);\n      }\n\n      return dispatchError(self, err, callback);\n    }\n\n    if (callback) {\n      try {\n        value = util.decodeValue(value, options);\n      } catch (e) {\n        return callback(new EncodingError(e));\n      }\n\n      callback(null, value);\n    }\n  });\n};\n\nLevelUP.prototype.put = function (key_, value_, options, callback) {\n  var self = this,\n      key,\n      value;\n  callback = getCallback(options, callback);\n\n  if (key_ === null || key_ === undefined || value_ === null || value_ === undefined) {\n    return dispatchError(this, new WriteError('put() requires key and value arguments'), callback);\n  }\n\n  if (!this._isOpening() && !this.isOpen()) {\n    return dispatchError(this, new WriteError('Database is not open'), callback);\n  }\n\n  options = getOptions(this, options);\n  key = util.encodeKey(key_, options);\n  value = util.encodeValue(value_, options);\n  this.db.put(key, value, options, function (err) {\n    if (err) {\n      return dispatchError(self, new WriteError(err), callback);\n    } else {\n      self.emit('put', key_, value_);\n      if (callback) callback();\n    }\n  });\n};\n\nLevelUP.prototype.del = function (key_, options, callback) {\n  var self = this,\n      key;\n  callback = getCallback(options, callback);\n\n  if (key_ === null || key_ === undefined) {\n    return dispatchError(this, new WriteError('del() requires a key argument'), callback);\n  }\n\n  if (!this._isOpening() && !this.isOpen()) {\n    return dispatchError(this, new WriteError('Database is not open'), callback);\n  }\n\n  options = getOptions(this, options);\n  key = util.encodeKey(key_, options);\n  this.db.del(key, options, function (err) {\n    if (err) {\n      return dispatchError(self, new WriteError(err), callback);\n    } else {\n      self.emit('del', key_);\n      if (callback) callback();\n    }\n  });\n};\n\nLevelUP.prototype.batch = function (arr_, options, callback) {\n  var self = this,\n      keyEnc,\n      valueEnc,\n      arr;\n  if (!arguments.length) return new Batch(this);\n  callback = getCallback(options, callback);\n\n  if (!Array.isArray(arr_)) {\n    return dispatchError(this, new WriteError('batch() requires an array argument'), callback);\n  }\n\n  if (!this._isOpening() && !this.isOpen()) {\n    return dispatchError(this, new WriteError('Database is not open'), callback);\n  }\n\n  options = getOptions(this, options);\n  keyEnc = options.keyEncoding;\n  valueEnc = options.valueEncoding;\n  arr = arr_.map(function (e) {\n    if (e.type === undefined || e.key === undefined) return {}; // inherit encoding\n\n    var kEnc = e.keyEncoding || keyEnc,\n        vEnc = e.valueEncoding || e.encoding || valueEnc,\n        o; // If we're not dealing with plain utf8 strings or plain\n    // Buffers then we have to do some work on the array to\n    // encode the keys and/or values. This includes JSON types.\n\n    if (kEnc != 'utf8' && kEnc != 'binary' || vEnc != 'utf8' && vEnc != 'binary') {\n      o = {\n        type: e.type,\n        key: util.encodeKey(e.key, options, e)\n      };\n      if (e.value !== undefined) o.value = util.encodeValue(e.value, options, e);\n      return o;\n    } else {\n      return e;\n    }\n  });\n  this.db.batch(arr, options, function (err) {\n    if (err) {\n      return dispatchError(self, new WriteError(err), callback);\n    } else {\n      self.emit('batch', arr_);\n      if (callback) callback();\n    }\n  });\n}; // DEPRECATED: prefer accessing LevelDOWN for this: db.db.approximateSize()\n\n\nLevelUP.prototype.approximateSize = function (start_, end_, callback) {\n  var self = this,\n      start,\n      end;\n\n  if (start_ === null || start_ === undefined || end_ === null || end_ === undefined || typeof callback != 'function') {\n    return dispatchError(this, new ReadError('approximateSize() requires start, end and callback arguments'), callback);\n  }\n\n  start = util.encodeKey(start_, this.options);\n  end = util.encodeKey(end_, this.options);\n\n  if (!this._isOpening() && !this.isOpen()) {\n    return dispatchError(this, new WriteError('Database is not open'), callback);\n  }\n\n  this.db.approximateSize(start, end, function (err, size) {\n    if (err) {\n      return dispatchError(self, new OpenError(err), callback);\n    } else if (callback) {\n      callback(null, size);\n    }\n  });\n};\n\nLevelUP.prototype.readStream = LevelUP.prototype.createReadStream = function (options) {\n  var self = this;\n  options = extend(this.options, options);\n  return new ReadStream(options, this, function (options) {\n    return self.db.iterator(options);\n  });\n};\n\nLevelUP.prototype.keyStream = LevelUP.prototype.createKeyStream = function (options) {\n  return this.createReadStream(extend(options, {\n    keys: true,\n    values: false\n  }));\n};\n\nLevelUP.prototype.valueStream = LevelUP.prototype.createValueStream = function (options) {\n  return this.createReadStream(extend(options, {\n    keys: false,\n    values: true\n  }));\n};\n\nLevelUP.prototype.writeStream = LevelUP.prototype.createWriteStream = function (options) {\n  return new WriteStream(extend(options), this);\n};\n\nLevelUP.prototype.toString = function () {\n  return 'LevelUP';\n};\n\nfunction utilStatic(name) {\n  return function (location, callback) {\n    getLevelDOWN()[name](location, callback || function () {});\n  };\n}\n\nmodule.exports = LevelUP;\nmodule.exports.copy = util.copy; // DEPRECATED: prefer accessing LevelDOWN for this: require('leveldown').destroy()\n\nmodule.exports.destroy = utilStatic('destroy'); // DEPRECATED: prefer accessing LevelDOWN for this: require('leveldown').repair()\n\nmodule.exports.repair = utilStatic('repair');","map":null,"metadata":{},"sourceType":"script"}