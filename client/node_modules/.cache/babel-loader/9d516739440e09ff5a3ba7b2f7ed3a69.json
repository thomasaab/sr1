{"ast":null,"code":"var Writable = require('readable-stream/writable');\n\nvar Readable = require('readable-stream/readable');\n\nvar peek = require('level-peek');\n\nvar util = require('util');\n\nvar once = require('once');\n\nvar EMPTY = new Buffer(0);\nvar ENCODER = {\n  encode: function (data) {\n    return typeof data === 'string' ? data = new Buffer(data) : data;\n  },\n  decode: function (data) {\n    return Buffer.isBuffer(data) ? data : new Buffer(data);\n  },\n  buffer: true,\n  type: 'raw'\n};\n\nvar noop = function () {};\n\nvar pad = function (n) {\n  n = n.toString(16);\n  return '00000000'.slice(0, -n.length) + n;\n};\n\nvar expand = function (buf, len) {\n  var tmp = new Buffer(len);\n  buf.copy(tmp);\n  return tmp;\n};\n\nmodule.exports = function (db, opts) {\n  if (!opts) opts = {};\n  var blobs = {};\n  var blockSize = opts.blockSize || 65536;\n  var maxBatch = opts.batch || 100;\n  var blank = new Buffer(blockSize);\n  db.put('\\x00', 'ignore', noop); // memdown#12 workaround\n\n  var reservations = {};\n\n  var mutateBlock = function (key, offset, block, append, cb) {\n    var release = function () {\n      if (! --reservations[key].locks) delete reservations[key];\n    };\n\n    var onreservation = function (r) {\n      r.locks++;\n\n      if (!r.block && !offset) {\n        r.block = block;\n        cb(null, r.block, release);\n        return;\n      }\n\n      if (!r.block) r.block = new Buffer(blockSize);\n      if (r.block.length < offset + block.length) r.block = expand(r.block, offset + block.length);\n      block.copy(r.block, offset);\n      if (!append && offset + block.length < r.block.length) r.block = r.block.slice(0, offset + block.length);\n      cb(null, r.block, release);\n    };\n\n    if (reservations[key]) return onreservation(reservations[key]);\n    db.get(key, {\n      valueEncoding: ENCODER\n    }, function (err, block) {\n      if (err && !err.notFound) return cb(err);\n      if (!reservations[key]) reservations[key] = {\n        locks: 0,\n        block: block\n      };\n      onreservation(reservations[key]);\n    });\n  };\n\n  var WriteStream = function (name, opts) {\n    if (!(this instanceof WriteStream)) return new WriteStream(name, opts);\n    if (!opts) opts = {};\n    this.name = name;\n    this.blocks = [];\n    this.batch = [];\n    this.bytesWritten = 0;\n    this.truncate = !opts.append;\n    this.append = opts.append;\n    this._shouldInitAppend = this.append && opts.start === undefined;\n    this._destroyed = false;\n\n    this._init(opts.start || 0);\n\n    Writable.call(this);\n  };\n\n  util.inherits(WriteStream, Writable);\n\n  WriteStream.prototype._init = function (start) {\n    this.blockIndex = start / blockSize | 0;\n    this.blockOffset = start - this.blockIndex * blockSize;\n    this.blockLength = this.blockOffset;\n  };\n\n  WriteStream.prototype._flush = function (cb) {\n    if (!this.batch.length) return cb();\n    var key = this.batch[this.batch.length - 1].key;\n    var batch = this.batch;\n    this.batch = [];\n    if (!this.truncate) return db.batch(batch, cb);\n    this.truncate = false;\n\n    this._truncate(batch, key, cb);\n  };\n\n  WriteStream.prototype._truncate = function (batch, key, cb) {\n    cb = once(cb);\n    var dels = [];\n    var keys = db.createKeyStream({\n      start: key,\n      end: this.name + '\\xff\\xff'\n    });\n    keys.on('error', cb);\n    keys.on('data', function (key) {\n      dels.push({\n        type: 'del',\n        key: key\n      });\n    });\n    keys.on('end', function () {\n      dels.push.apply(dels, batch);\n      db.batch(dels, cb);\n    });\n  };\n\n  WriteStream.prototype._writeBlock = function (cb) {\n    var block = this.blocks.length === 1 ? this.blocks[0] : Buffer.concat(this.blocks, this.blockLength - this.blockOffset);\n    var index = this.blockIndex;\n    var offset = this.blockOffset;\n    var self = this;\n    this.blockOffset = 0;\n    this.blockLength = 0;\n    this.blockIndex++;\n    this.blocks = [];\n    var key = this.name + '\\xff' + pad(index);\n\n    var append = function (block, force, cb) {\n      if (block.length) {\n        self.batch.push({\n          type: 'put',\n          key: key,\n          value: block,\n          valueEncoding: ENCODER\n        });\n      }\n\n      if (!force && self.batch.length < maxBatch) return cb();\n      return self._flush(cb);\n    };\n\n    if (!offset && block.length === blockSize) return append(block, false, cb);\n    if (!offset && !this.append) return append(block, false, cb); // partial write\n\n    mutateBlock(key, offset, block, this.append, function (err, block, release) {\n      if (err) return cb(err);\n      append(block, true, function (err) {\n        release();\n        cb(err);\n      });\n    });\n  };\n\n  WriteStream.prototype._initAppend = function (data, enc, cb) {\n    var self = this;\n    this._shouldInitAppend = false;\n    blobs.size(this.name, function (err, size) {\n      if (err) return cb(err);\n\n      self._init(size);\n\n      self._write(data, enc, cb);\n    });\n  };\n\n  WriteStream.prototype._write = function (data, enc, cb) {\n    if (!data.length || this._destroyed) return cb();\n    if (this._shouldInitAppend) return this._initAppend(data, enc, cb);\n    var self = this;\n    var overflow;\n    var free = blockSize - this.blockLength;\n\n    var done = function (err) {\n      if (err) return cb(err);\n      if (overflow) return self._write(overflow, enc, cb);\n      cb();\n    };\n\n    if (data.length > free) {\n      overflow = data.slice(free);\n      data = data.slice(0, free);\n    }\n\n    this.bytesWritten += data.length;\n    this.blockLength += data.length;\n    this.blocks.push(data);\n    if (data.length < free) return done();\n\n    this._writeBlock(done);\n  };\n\n  WriteStream.prototype.destroy = function () {\n    if (this._destroyed) return;\n    this._destroyed = true;\n    process.nextTick(this.emit.bind(this, 'close'));\n  };\n\n  WriteStream.prototype.end = function (data) {\n    var self = this;\n    var args = arguments;\n\n    if (data && typeof data !== 'function') {\n      this.write(data);\n      data = EMPTY;\n    }\n\n    this.write(EMPTY, function () {\n      self._writeBlock(function (err) {\n        if (err) return self.emit('error', err);\n\n        self._flush(function (err) {\n          if (err) return self.emit('error', err);\n          Writable.prototype.end.apply(self, args);\n        });\n      });\n    });\n  };\n\n  var ReadStream = function (name, opts) {\n    if (!opts) opts = {};\n    var self = this;\n    var start = opts.start || 0;\n    var blockIndex = start / blockSize | 0;\n    var blockOffset = start - blockIndex * blockSize;\n    var key = name + '\\xff' + pad(blockIndex);\n    this.name = name;\n    this._missing = (typeof opts.end === 'number' ? opts.end : Infinity) - start + 1;\n    this._paused = false;\n    this._destroyed = false;\n    this._reader = db.createReadStream({\n      start: key,\n      end: name + '\\xff\\xff',\n      valueEncoding: ENCODER\n    });\n\n    var onblock = function (val) {\n      key = name + '\\xff' + pad(++blockIndex);\n      if (!self._missing) return false;\n\n      if (blockOffset) {\n        val = val.slice(blockOffset);\n        blockOffset = 0;\n        if (!val.length) return true;\n      }\n\n      if (val.length > self._missing) val = val.slice(0, self._missing);\n      self._missing -= val.length;\n\n      self._pause(!self.push(val));\n\n      return !!self._missing;\n    };\n\n    this._reader.on('data', function (data) {\n      while (data.key > key) {\n        if (!onblock(blank)) return;\n      }\n\n      onblock(data.value);\n    });\n\n    this._reader.on('error', function (err) {\n      self.emit('error', err);\n    });\n\n    this._reader.on('end', function () {\n      self.push(null);\n    });\n\n    Readable.call(this);\n  };\n\n  util.inherits(ReadStream, Readable);\n\n  ReadStream.prototype.destroy = function () {\n    if (this._destroyed) return;\n    this._destroyed = true;\n\n    this._reader.destroy();\n\n    process.nextTick(this.emit.bind(this, 'close'));\n  };\n\n  ReadStream.prototype._pause = function (paused) {\n    if (this._paused === paused) return;\n    this._paused = paused;\n    if (this._paused) this._reader.pause();else this._reader.resume();\n  };\n\n  ReadStream.prototype._read = function () {\n    this._pause(false);\n  };\n\n  blobs.remove = function (name, cb) {\n    cb = once(cb || noop);\n    var batch = [];\n    var keys = db.createKeyStream({\n      start: name + '\\xff',\n      end: name + '\\xff\\xff'\n    });\n    keys.on('error', cb);\n    keys.on('data', function (key) {\n      batch.push({\n        type: 'del',\n        key: key\n      });\n    });\n    keys.on('end', function () {\n      db.batch(batch, cb);\n    });\n  };\n\n  blobs.size = function (name, cb) {\n    peek.last(db, {\n      start: name + '\\xff',\n      end: name + '\\xff\\xff',\n      valueEncoding: ENCODER\n    }, function (err, latest, val) {\n      if (err && err.message === 'range not found') return cb(null, 0);\n      if (err) return cb(err);\n      if (latest.slice(0, name.length + 1) !== name + '\\xff') return cb(null, 0);\n      cb(null, parseInt(latest.toString().slice(name.length + 1), 16) * blockSize + val.length);\n    });\n  };\n\n  blobs.write = function (name, data, opts, cb) {\n    if (typeof opts === 'function') return blobs.write(name, data, null, opts);\n    if (!opts) opts = {};\n    if (!cb) cb = noop;\n    var ws = blobs.createWriteStream(name, opts);\n    ws.on('error', cb);\n    ws.on('finish', function () {\n      cb();\n    });\n    ws.write(data);\n    ws.end();\n  };\n\n  blobs.read = function (name, opts, cb) {\n    if (typeof opts === 'function') return blobs.read(name, null, opts);\n    if (!opts) opts = {};\n    var rs = blobs.createReadStream(name, opts);\n    var list = [];\n    rs.on('error', cb);\n    rs.on('data', function (data) {\n      list.push(data);\n    });\n    rs.on('end', function () {\n      cb(null, list.length === 1 ? list[0] : Buffer.concat(list));\n    });\n  };\n\n  blobs.createReadStream = function (name, opts) {\n    return new ReadStream(name, opts);\n  };\n\n  blobs.createWriteStream = function (name, opts) {\n    return new WriteStream(name, opts);\n  };\n\n  return blobs;\n};","map":null,"metadata":{},"sourceType":"script"}